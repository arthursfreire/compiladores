package util;

import java_cup.runtime.*;
import util.*;
import semantica.*;
import java.util.ArrayList;
import java.util.List;

parser code {: 
     public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
	
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException(message);
        //System.exit(1);
    }
   
:};

/* -------------------------------------------------- *
 *            Key Words Declarations                  *
 * -------------------------------------------------- */

terminal	ABSTRACT;
terminal	AS;
terminal	BASE;
terminal 	BOOL;
terminal 	BREAK;
terminal	BYTE;
terminal	CASE;
terminal	CATCH;
terminal	CHAR;
terminal	CHECKED;
terminal	CLASS;
terminal	CONST;
terminal	CONTINUE;
terminal	DECIMAL;
terminal	DEFAULT;
terminal	DELEGATE;
terminal	DO;
terminal	DOUBLE;
terminal	ELSE;
terminal	ENUM;
terminal	EVENT;
terminal	EXPLICIT;
terminal	EXTERN;
terminal	FINALLY;
terminal	FIXED;
terminal	FLOAT;
terminal	FOR;
terminal	FOREACH;
terminal	GOTO;
terminal	IF;
terminal	IMPLICIT;
terminal	IN;
terminal	INT;
terminal	INTERFACE;
terminal	INTERNAL;
terminal	IS;
terminal	LOCK;
terminal	LONG;
terminal	NAMESPACE;
terminal	NEW;
terminal	OBJECT;
terminal	OPERATOR;
terminal	OUT;
terminal	OVERRIDE;
terminal	PARAMS;
terminal	PRIVATE;
terminal	PROTECTED;
terminal	PUBLIC;
terminal	READONLY;
terminal	REF;
terminal	RETURN;
terminal	SBYTE;
terminal	SEALED;
terminal	SHORT;
terminal	SIZEOF;
terminal	STACKALLOC;
terminal	STATIC;
terminal	STRING;
terminal	STRUCT;
terminal	SWITCH;
terminal	THIS;
terminal	THROW;
terminal	TRY;
terminal	TYPEOF;
terminal	UINT;
terminal	ULONG;
terminal	UNCHECKED;
terminal	UNSAFE;
terminal	USHORT;
terminal	USING;
terminal	VIRTUAL;
terminal	VOID;
terminal	VOLATILE;
terminal	WHILE;


/* -------------------------------------------------- *
 *            Boolean Literals Declarations           *
 * -------------------------------------------------- */
 
 terminal	TRUE;
 terminal	FALSE;
 
 
/* -------------------------------------------------- *
 *            Null Literal Declarations               *
 * -------------------------------------------------- */
 
terminal	NULL;
 
/* -------------------------------------------------- *
 *            Operators and Punctuators Declarations  *
 * -------------------------------------------------- */
 
terminal	EQ;
terminal	GT;
terminal	LT;
terminal	NOT;
terminal	COMP;
terminal	QUESTION;
terminal	EQEQ;
terminal	LTEQ;
terminal	GTEQ;
terminal	NOTEQ;
terminal	ANDAND;
terminal	OROR;
terminal	PLUSPLUS;
terminal	MINUSMINUS;
terminal	PLUS;
terminal	MINUS;
terminal	MULT;
terminal	DIV;
terminal	AND;
terminal	OR;
terminal	XOR;
terminal	MOD;
terminal	LSHIFT;
terminal	RSHIFT;
terminal	PLUSEQ;
terminal	MINUSEQ;
terminal	MULTEQ;
terminal	DIVEQ;
terminal	ANDEQ;
terminal	OREQ;
terminal	XOREQ;
terminal	MODEQ;
terminal	LSHIFTEQ;
terminal	RSHIFTEQ;
terminal	LPAREN;
terminal	RPAREN;
terminal	LBRACE;
terminal	RBRACE;
terminal	LBRACK;
terminal	RBRACK;
terminal	COLON;
terminal	SEMICOLON;
terminal	COMMA;
terminal	DOT;

terminal	IDENTIFIER;
terminal	INTEGER_LITERAL;
terminal	REAL_LITERAL;
terminal	STRING_LITERAL;

terminal	GET;
terminal	SET;

terminal	ADD;
terminal	REMOVE;

terminal	ASSEMBLY;

terminal	FIELD;
terminal	METHOD;
terminal	MODULE;
terminal	PARAM;
terminal	PROPERTY;
terminal	TYPE;


/* -------------------------------------------------- *
 *            Main Productions Declarations           *
 * -------------------------------------------------- */
 
non terminal	namespace_name;
non terminal	type_name;
non terminal	namespace_or_type_name;
non terminal	type;
non terminal	variable_reference;
non terminal	argument_list;
non terminal	statement;
non terminal	compilation_unit;
non terminal	class_declaration;
non terminal	struct_declaration;
non terminal	array_type;
non terminal	interface_declaration;
non terminal	enum_declaration;
non terminal	delegate_declaration;
non terminal	global_attributes;
non terminal	namespace_or_type_name_line;

non terminal	literal;

/* -------------------------------------------------- *
 *                 Types Declarations                 *
 * -------------------------------------------------- */

non terminal	InterfaceType;
non terminal	ArrayType;

/* -------------------------------------------------- *
 *              Expressions Declarations              *
 * -------------------------------------------------- */

non terminal	Argument;
non terminal	PrimaryExpression;
non terminal	PrimaryNoArrayCreationExpression;
non terminal	ParenthesizedExpression;
non terminal	MemberAccess;
non terminal	PredefinedType;
non terminal	InvocationExpression;
non terminal	ElementAccess;
non terminal	ExpressionList;
non terminal	ThisAccess;
non terminal	BaseAccess;
non terminal	PostIncrementExpression;
non terminal	PostDecrementExpression;
non terminal	ObjectCreationExpression;
non terminal	ArrayCreationExpression;
non terminal	DelegateCreationExpression;
non terminal	TypeofExpression;
non terminal	SizeofExpression;
non terminal	CheckedExpression;
non terminal	UncheckedExpression;
non terminal	UnaryExpression;
non terminal	PreIncrementExpression;
non terminal	PreDecrementExpression;
non terminal	CastExpression;
non terminal	MultiplicativeExpression;
non terminal	AdditiveExpression;
non terminal	ShiftExpression;
non terminal	RelationalExpression;
non terminal	EqualityExpression;
non terminal	AndExpression;
non terminal	ExclusiveOrExpression;
non terminal	InclusiveOrExpression;
non terminal	ConditionalAndExpression;
non terminal	ConditionalOrExpression;
non terminal	ConditionalExpression;
non terminal	Assignment;
non terminal	AssignmentOperator;
non terminal	Expression;
non terminal	ConstantExpression;

/* -------------------------------------------------- *
 *              Statements Declarations               *
 * -------------------------------------------------- */
 
non terminal	EmbeddedStatement;
non terminal	Block;
non terminal	StatementList;
non terminal	EmptyStatement;
non terminal	LabeledStatement;
non terminal	DeclarationStatement;
non terminal	ExpressionStatement;
non terminal	JumpStatement;
non terminal	TryStatement;
non terminal	CheckedStatement;
non terminal	UncheckedStatement;
non terminal	LockStatement;
non terminal	UsingStatement;
non terminal	LocalVariableDeclaration;
non terminal	LocalConstantDeclaration;
non terminal	LocalVariableDeclarators;
non terminal	LocalVariableDeclarator;
non terminal	LocalVariableInitializer;
non terminal	StatementExpression;
non terminal	SelectionStatement;
non terminal	IfStatement;
non terminal	SwitchStatement;
non terminal	BooleanExpression;
non terminal	SwitchBlock;
non terminal	SwitchSections;
non terminal	SwitchSection;
non terminal	SwitchLabels;
non terminal	SwitchLabel;
non terminal	IterationStatement;
non terminal	WhileStatement;
non terminal	DoStatement;
non terminal	ForStatement;
non terminal	ForeachStatement;
non terminal	ForInitializer;
non terminal	ForCondition;
non terminal	ForIterator;
non terminal	StatementExpressionList;
non terminal	BreakStatement;
non terminal	ContinueStatement;
non terminal	GotoStatement;
non terminal	ReturnStatement;
non terminal	ThrowStatement;
non terminal	CatchClauses;
non terminal	SpecificCatchClauses;
non terminal	SpecificCatchClause;
non terminal	GeneralCatchClause;
non terminal	FinallyClause;
non terminal	UncheckedCatchClause;
non terminal	ResourceAcquisition;

/* -------------------------------------------------- *
 *               Namespace Declarations               *
 * -------------------------------------------------- */

non terminal	UsingDirectives;
non terminal	NamespaceMemberDeclarations;
non terminal	NamespaceMemberDeclaration;
non terminal	NamespaceDeclaration;
non terminal	QualifiedIdentifier;
non terminal	NamespaceBody;
non terminal	UsingDirective;
non terminal	UsingAliasDirective;
non terminal	UsingNamespaceDirective;
non terminal	TypeDeclaration;

/* -------------------------------------------------- *
 *                Classes Declarations                *
 * -------------------------------------------------- */
 
non terminal	ClassBase;
non terminal	InterfaceTypeList;
non terminal	ClassBody;
non terminal	ClassMemberDeclarations;
non terminal	ClassMemberDeclaration;
non terminal	ConstantDeclaration;
non terminal	ConstantDeclarators;
non terminal	ConstantDeclarator;
non terminal	FieldDeclaration;
non terminal	VariableDeclarators;
non terminal	VariableDeclarator;
non terminal	VariableInitializer;
non terminal	MethodDeclaration;
non terminal	MethodHeader;
non terminal	ReturnType;
non terminal	MemberName;
non terminal	MethodBody;
non terminal	FormalParameterList;
non terminal	FixedParameters;
non terminal	FixedParameter;
non terminal	ParameterArray;
non terminal	PropertyDeclaration;
non terminal	AcessorDeclarations;
non terminal	GetAcessorDeclaration;
non terminal	SetAcessorDeclaration;
non terminal	AcessorBody;
non terminal	EventDeclaration;
non terminal	EventAcessorDeclarations;
non terminal	AddAcessorDeclaration;
non terminal	RemoveAcessorDeclaration;
non terminal	IndexerDeclaration;
non terminal	IndexerDeclarator;
non terminal	OperatorDeclaration;
non terminal	OperatorDeclarator;
non terminal	UnaryOperatorDeclarator;
non terminal	BinaryOperatorDeclarator;
non terminal	ConversionOperatorDeclarator;
non terminal	OperatorBody;
non terminal	ConstructorDeclaration;
non terminal	ConstructorDeclarator;
non terminal	ConstructorInitializer;
non terminal	ConstructorBody;
non terminal	StaticConstructorDeclaration;
non terminal	StaticConstructorBody;
non terminal	DestructorDeclaration;
non terminal	DestructorBody;

/* -------------------------------------------------- *
 *                Structs Declarations                *
 * -------------------------------------------------- */

non terminal	StructInterfaces;
non terminal	StructMemberDeclarations;
non terminal	StructMemberDeclaration;

/* -------------------------------------------------- *
 *                 Array Declarations                 *
 * -------------------------------------------------- */

non terminal	NonArrayType;
non terminal	RankSpecifiers;
non terminal	RankSpecifier;
non terminal	DimSeparators; 
non terminal	ArrayInitializer;
non terminal	VariableInitializerList;

/* -------------------------------------------------- *
 *               Interfaces Declarations              *
 * -------------------------------------------------- */
 
non terminal	InterfaceBase;
non terminal	InterfaceMemberDeclarations;
non terminal	InterfaceMemberDeclaration;
non terminal	InterfaceMethodDeclaration;
non terminal	InterfacePropertyDeclaration;
non terminal	InterfaceAcessors;
non terminal	InterfaceEventDeclaration;
non terminal	InterfaceIndexerDeclaration;

/* -------------------------------------------------- *
 *                 Enum Declarations                  *
 * -------------------------------------------------- */

non terminal	EnumBase;
non terminal	EnumMemberDeclarations;
non terminal	EnumMemberDeclaration;

/* -------------------------------------------------- *
 *              Attributes Declarations               *
 * -------------------------------------------------- */
 
non terminal	GlobalAttributeSections;
non terminal	GlobalAttributeSection;
non terminal	GlobalAttributeTargetSpecifier;
non terminal	Attributes;
non terminal	AttributeSections;
non terminal	AttributeSection;
non terminal	AttributeTargetSpecifier;
non terminal	AttributeTarget;
non terminal	AttributeList;
non terminal	Attribute;
non terminal	AttributeName;
non terminal	AttributeArguments;
non terminal	PositionalArgumentList;
non terminal	PositionalArgument;
non terminal	NamedArgumentList;
non terminal	NamedArgument;
non terminal	AttributeArgumentExpression;

/* -------------------------------------------------- *
 *             Possibilities Declarations             *
 * -------------------------------------------------- */

non terminal	Modifier;
non terminal	Modifier_Opt;
non terminal	Modifiers;
non terminal	Modifiers_Opt;
non terminal	ClassMemberDeclaration_Possibilities;
non terminal	Operator;
non terminal	IntegralType_Possibilities;
non terminal	StructMemberDeclaration_Possibilities;
non terminal	EmbeddedStatement_Possibilities;
non terminal	StatementExpression_Possibilities;

/* -------------------------------------------------- *
 *               Repetition Declarations              *
 * -------------------------------------------------- */
 
non terminal	AttributesOpt_ModifiersOpt_Event_Type;
non terminal	Operator_Type_Lparen_Type_Identifier_Rparen;
non terminal	AttributesOpt_Get_Semicolon;
non terminal	AttributesOpt_Set_Semicolon;
non terminal	AttibutesOpt_Identifier;
 
/* -------------------------------------------------- *
 *                Optional Declarations               *
 * -------------------------------------------------- */

non terminal	UsingDirectives_Opt;
non terminal	GlobalAttributes_Opt;
non terminal	NamespaceMemberDeclarations_Opt;
non terminal	Semicolon_Opt;
non terminal	Attributes_Opt;
non terminal	ClassBase_Opt;
non terminal	ClassMemberDeclarations_Opt;
non terminal	FormalParameterList_Opt;
non terminal	SetAcessorDeclaration_Opt;
non terminal	GetAcessorDeclaration_Opt;
non terminal	ConstructorInitializer_Opt;
non terminal	ArgumentList_Opt;
non terminal	DimSeparators_Opt;
non terminal	VariableInitializerList_Opt;
non terminal	InterfaceBase_Opt;
non terminal	InterfaceMemberDeclarations_Opt;
non terminal	StructInterfaces_Opt;
non terminal	StructMemberDeclarations_Opt;
non terminal	EnumBase_Opt;
non terminal	EnumMemberDeclarations_Opt;
non terminal	AttributeTargetSpecifier_Opt;
non terminal	AttributeArguments_Opt;
non terminal	PositionalArgumentList_Opt;
non terminal	Comma_Opt;
non terminal	StatementList_Opt;
non terminal	SwitchSections_Opt;
non terminal	ForInitializer_Opt;
non terminal	ForCondition_Opt;
non terminal	ForIterator_Opt;
non terminal	Expression_Opt;
non terminal	GeneralCatchClause_Opt;
non terminal	SpecificCatchClauses_Opt;
non terminal	Identifier_Opt;
non terminal	RankSpecifiers_Opt;
non terminal	ArrayInitializer_Opt;



precedence left 	THIS, OPERATOR;
precedence left		STATIC;
precedence left 	IDENTIFIER;
precedence left 	BOOL, DECIMAL; 
precedence left 	SBYTE, BYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, CHAR, DOUBLE, FLOAT, STRING, OBJECT;
precedence left 	LBRACE, RBRACE;
precedence left 	LBRACK, RBRACK;
precedence left 	LPAREN, RPAREN;
precedence left 	IF, ELSE, RETURN, CONTINUE, BREAK;
precedence left		CATCH, WHILE;
precedence left		FINALLY;
precedence left		VOID;



start with compilation_unit;

/* ################################################## */
/* #################### GRAMMAR ##################### */
/* ################################################## */


literal
	::= TRUE:t {: Logger.print("BooleanLiteral: " + true); RESULT = new Expression("true", new Type("bool")); :} |
		FALSE:f {: Logger.print("BooleanLiteral: " + false); RESULT = new Expression("false", new Type("bool")); :} |
		INTEGER_LITERAL:i {: Logger.print("IntegerLiteral: " + i); RESULT = new Expression((String) i, new Type("int")); :} |
		REAL_LITERAL:r {: Logger.print("RealLiteral: " + r); :} |
		STRING_LITERAL:s {: Logger.print("StringLiteral: " + s); RESULT = new Expression((String) s, new Type("string")); :} |
		NULL:n  {: Logger.print("NullLiteral: " + n); :}
		;

/* -------------------------------------------------- *
 *                   Basic Concepts                   *
 * -------------------------------------------------- */

namespace_name
	::= namespace_or_type_name
		;
		
type_name
	::= namespace_or_type_name
		;
		
namespace_or_type_name
	::= IDENTIFIER:i {: Logger.print("IDENTIFIER: " + i); RESULT = i; :} | 
		namespace_or_type_name:n DOT IDENTIFIER:i {: RESULT = n + "." + i; :}
		;
		
/* -------------------------------------------------- *
 *                       Types                        *
 * -------------------------------------------------- */
 
type
	::= namespace_or_type_name:n {: Logger.print("Type: namespace_or_type_name"); RESULT = new Expression((String) n, new Type("identifier")); :} |
		IntegralType_Possibilities:i {: Logger.print("Type: Integral Possibilities"); RESULT = i; :} |
		BOOL:b {: Logger.print("Type: bool"); RESULT = new Expression((String) b, new Type("bool")); :} |
		FLOAT:f {: Logger.print("Type: float"); RESULT = new Expression((String) f, new Type("float")); :} |
		DOUBLE:d {: Logger.print("Type: double"); RESULT = new Expression((String) d, new Type("double")); :} |
		DECIMAL:d {: Logger.print("Type: decimal"); RESULT = new Expression((String) d, new Type("decimal")); :} |
		OBJECT:o {: Logger.print("Type: object"); RESULT = new Expression((String) o, new Type("object")); :} |
		STRING:s {: Logger.print("Type: string"); RESULT = new Expression((String) s, new Type("string")); :} |
		VOID:v {: Logger.print("Type: void"); RESULT = new Expression((String) v, new Type("void")); :} |
		array_type:a {: Logger.print("Type: ArrayType Doing nothing."); :}
		;
		 
/* -------------------------------------------------- *
 *                     Variables                      *
 * -------------------------------------------------- */
 
variable_reference
	::= Expression
		;
 
/* -------------------------------------------------- *
 *                    Expressions                     *
 * -------------------------------------------------- */

argument_list
	::= Argument |
		argument_list COMMA Argument
		;
		
Argument
	::= Expression |
		REF variable_reference |
		OUT variable_reference
		;
		
PrimaryExpression
	::= PrimaryNoArrayCreationExpression:p
		{: Logger.print("PrimaryExpression PrimaryNoArrayCreationExpression: " + p);
		   RESULT = p; :} |
		ArrayCreationExpression
		;
		
PrimaryNoArrayCreationExpression
	::= literal:l {: Logger.print("PrimaryNoArrayCreationExpression literal: " + l); RESULT = l; :} |
		IDENTIFIER:i {: Logger.print("PrimaryNoArrayCreationExpression IDENTIFIER: " + i); RESULT = new Expression((String) i, new Type("identifier")); :}  |
		ParenthesizedExpression:p {: Logger.print("PrimaryNoArrayCreationExpression ParenthesizedExpression: " + p); RESULT = p; :}  |
		MemberAccess {: Logger.print("PrimaryNoArrayCreationExpression MemberAccess"); :} |
		InvocationExpression:i {: Logger.print("PrimaryNoArrayCreationExpression InvocationExpression: " + i); RESULT = i; :}  |
		ElementAccess {: Logger.print("PrimaryNoArrayCreationExpression ElementAccess"); :} |
		ThisAccess {: Logger.print("PrimaryNoArrayCreationExpression ThisAccess"); :} |
		BaseAccess {: Logger.print("PrimaryNoArrayCreationExpression BaseAccess"); :} |
		PostIncrementExpression:p {: Logger.print("PrimaryNoArrayCreationExpression PostIncrementExpression: " + p); RESULT = p; :} |
		PostDecrementExpression:p {: Logger.print("PrimaryNoArrayCreationExpression PostDecrementExpression: " + p); RESULT = p; :} |
		ObjectCreationExpression {: Logger.print("PrimaryNoArrayCreationExpression ObjectCreationExpression"); :} |
		DelegateCreationExpression  {: Logger.print("PrimaryNoArrayCreationExpression DelegateCreationExpression"); :}|
		TypeofExpression  {: Logger.print("PrimaryNoArrayCreationExpression TypeofExpression"); :} |
		SizeofExpression {: Logger.print("PrimaryNoArrayCreationExpression SizeofExpression"); :} |
		CheckedExpression {: Logger.print("PrimaryNoArrayCreationExpression CheckedExpression"); :} |
		UncheckedExpression {: Logger.print("PrimaryNoArrayCreationExpression UncheckedExpression"); :}
		;
		
ParenthesizedExpression
	::= LPAREN Expression:e RPAREN
		{: Logger.print("ParethensizedExpression: " + e); RESULT = e; :}
		;
		
MemberAccess
	::= PrimaryExpression DOT IDENTIFIER |		
		PredefinedType DOT IDENTIFIER
		;
		
PredefinedType
	::= BOOL | BYTE | CHAR | DECIMAL | DOUBLE | FLOAT | INT | LONG |
		OBJECT | SBYTE | SHORT | STRING | UINT | ULONG | USHORT
		;		

InvocationExpression
	::= PrimaryExpression LPAREN ArgumentList_Opt RPAREN
		;
		
ElementAccess
	::= PrimaryNoArrayCreationExpression LBRACK ExpressionList RBRACK
		;
		
ExpressionList
	::= Expression |
		ExpressionList COMMA Expression
		;
		
ThisAccess
	::= THIS
		;
		
BaseAccess
	::= BASE DOT IDENTIFIER |
		BASE LBRACK ExpressionList RBRACK
		;

PostIncrementExpression
	::= PrimaryExpression:p PLUSPLUS
		{: Logger.print("PostIncrementExpression: " + p); RESULT = p; :}
		;
		
PostDecrementExpression
	::= PrimaryExpression:p MINUSMINUS
		{: Logger.print("PostDecrementExpression: " + p); RESULT = p; :}
		;
		
ObjectCreationExpression
	::= NEW type LPAREN ArgumentList_Opt RPAREN |
		NEW namespace_or_type_name LPAREN ArgumentList_Opt RPAREN
		;
		
ArrayCreationExpression
	::= NEW type LBRACK ExpressionList RBRACK RankSpecifiers_Opt ArrayInitializer_Opt |
		NEW array_type ArrayInitializer
		;
		
DelegateCreationExpression
	::= NEW namespace_or_type_name LPAREN Expression RPAREN
		;
		
TypeofExpression
	::= TYPEOF LPAREN type RPAREN
		;
		
CheckedExpression
	::= CHECKED LPAREN Expression RPAREN
		;
		
UncheckedExpression
	::= UNCHECKED LPAREN Expression RPAREN
		;
		
UnaryExpression
	::= PrimaryExpression:p 
		{: Logger.print("UnaryExpression PrimaryExpression: " + p); RESULT = p; :} |
		
		PLUS UnaryExpression:u 
		{: Logger.print("UnaryExpression PLUS UnaryExpression: " + u); RESULT = u; :} |
		
		MINUS UnaryExpression:u 
		{: Logger.print("UnaryExpression MINUS UnaryExpression: " + u); RESULT = u; :} |
		
		NOT UnaryExpression:u 
		{: Logger.print("UnaryExpression NOT UnaryExpression: " + u); RESULT = u; :} |
		
		COMP UnaryExpression:u 
		{: Logger.print("UnaryExpression COMP UnaryExpression: " + u); RESULT = u; :} |
		
		MULT UnaryExpression:u 
		{: Logger.print("UnaryExpression MULT UnaryExpression: " + u); RESULT = u; :} |
		
		PreIncrementExpression:p 
		{: Logger.print("UnaryExpression PreIncrementExpression: " + p); RESULT = p; :} |
		
		PreDecrementExpression:p 
		{: Logger.print("UnaryExpression PostIncrementExpression: " + p); RESULT = p; :} |
		
		CastExpression
		{: Logger.print("UnaryExpression CastExpression"); :}
		;
		
PreIncrementExpression
	::= PLUSPLUS PrimaryExpression:p
		{: Logger.print("PreIncrementExpression: " + p); RESULT = p; :}
		;
		
PreDecrementExpression
	::= MINUSMINUS PrimaryExpression:p
		{: Logger.print("PreDecrementExpression: " + p); RESULT = p; :}
		;
		
CastExpression
	::= LPAREN type RPAREN UnaryExpression
		;
		
MultiplicativeExpression
	::= UnaryExpression:u 
		{: Logger.print("MultiplicativeExpression UnaryExpression: " + u); RESULT = u; :} |
		MultiplicativeExpression MULT UnaryExpression |
		MultiplicativeExpression DIV UnaryExpression |
		MultiplicativeExpression MOD UnaryExpression
		;
		
AdditiveExpression
	::= MultiplicativeExpression:m 
		{: Logger.print("AdditiveExpression MultiplicativeExpression: " + m); RESULT = m; :} |
		
		AdditiveExpression PLUS MultiplicativeExpression |
		AdditiveExpression MINUS MultiplicativeExpression
		;
		
ShiftExpression
	::= AdditiveExpression:a 
		{: Logger.print("ShiftExpression AdditiveExpression: " + a); RESULT = a; :} |
		
		ShiftExpression LSHIFT AdditiveExpression |
		ShiftExpression RSHIFT AdditiveExpression
		;
		
RelationalExpression
	::= ShiftExpression:s 
		{: Logger.print("Relationalxpression ShiftExpression: " + s); RESULT = s; :} |
		
		RelationalExpression:r LT ShiftExpression:s 
		{: Logger.print("Relationalxpression: RelationalExpression " + r + " < ShiftExpression " + s);
		   Expression e = (Expression) r;
		   Expression e1 = (Expression) s;
		   if ((!e.type.toString().equals("int")) || (!e1.type.toString().equals("int"))) {
		       throw new SemanticException("Illegal Operation in If Condition for " + e.type + " and " + e1.type);
		   }
		   
		   Expression res = new Expression();
		   res.value = e.value + " < " + e1.value;
		   res.type = new Type("bool");
		   RESULT = res; :} |
		
		RelationalExpression:r GT ShiftExpression:s 
		{: Logger.print("Relationalxpression: RelationalExpression " + r + " > ShiftExpression " + s);
		   Expression e = (Expression) r;
		   Expression e1 = (Expression) s;
		   if ((!e.type.toString().equals("int")) || (!e1.type.toString().equals("int"))) {
		       throw new SemanticException("Illegal Operation in If Condition for " + e.type + " and " + e1.type);
		   }
		   
		   Expression res = new Expression();
		   res.value = e.value + " > " + e1.value;
		   res.type = new Type("bool");
		   RESULT = res; :} |
		
		RelationalExpression:r LTEQ ShiftExpression:s 
		{: Logger.print("Relationalxpression: RelationalExpression " + r + " <= ShiftExpression " + s);
		   Expression e = (Expression) r;
		   Expression e1 = (Expression) s;
		   if ((!e.type.toString().equals("int")) || (!e1.type.toString().equals("int"))) {
		       throw new SemanticException("Illegal Operation in If Condition for " + e.type + " and " + e1.type);
		   }
		   
		   Expression res = new Expression();
		   res.value = e.value + " <= " + e1.value;
		   res.type = new Type("bool");
		   RESULT = res; :} |
		
		RelationalExpression:r GTEQ ShiftExpression:s 
		{: Logger.print("Relationalxpression: RelationalExpression " + r + " >= ShiftExpression " + s);
		   Expression e = (Expression) r;
		   Expression e1 = (Expression) s;
		   if ((!e.type.toString().equals("int")) || (!e1.type.toString().equals("int"))) {
		       throw new SemanticException("Illegal Operation in If Condition for " + e.type + " and " + e1.type);
		   }
		   
		   Expression res = new Expression();
		   res.value = e.value + " >= " + e1.value;
		   res.type = new Type("bool");
		   RESULT = res; :} |
		
		RelationalExpression:r IS ShiftExpression:s 
		{: Logger.print("Relationalxpression: RelationalExpression " + r + " IS ShiftExpression " + s); 
		   Expression e = (Expression) r;
		   Expression e1 = (Expression) s;
		   if ((!e.type.toString().equals("int")) || (!e1.type.toString().equals("int"))) {
		       throw new SemanticException("Illegal Operation in If Condition for " + e.type + " and " + e1.type);
		   }
		   
		   Expression res = new Expression();
		   res.value = e.value + " is " + e1.value;
		   res.type = new Type("bool");
		   RESULT = res; :} |
		
		RelationalExpression:r AS ShiftExpression:s
		{: Logger.print("Relationalxpression: RelationalExpression " + r + " AS ShiftExpression " + s); 
		   Expression e = (Expression) r;
		   Expression e1 = (Expression) s;
		   if ((!e.type.toString().equals("int")) || (!e1.type.toString().equals("int"))) {
		       throw new SemanticException("Illegal Operation in If Condition for " + e.type + " and " + e1.type);
		   }
		   
		   Expression res = new Expression();
		   res.value = e.value + " as " + e1.value;
		   res.type = new Type("bool");
		   RESULT = res; :}
		;
		
EqualityExpression
	::= RelationalExpression:r 
		{: Logger.print("EqualityExpression RelationalExpression: " + r); RESULT = r; :} |
		
		EqualityExpression EQEQ RelationalExpression |
		EqualityExpression NOTEQ RelationalExpression
		;
		
AndExpression
	::= EqualityExpression:e 
		{: Logger.print("AndExpression EqualityExpression: " + e); RESULT = e; :} | 
		EqualityExpression AND EqualityExpression
		;
		
ExclusiveOrExpression
	::= AndExpression:a 
		{: Logger.print("ExclusiveOrExpression AndExpression: " + a); RESULT = a; :} |
		ExclusiveOrExpression XOR AndExpression
		;
		
InclusiveOrExpression
	::= ExclusiveOrExpression:e 
		{: Logger.print("InclusiveOrExpression ExclusiveOrExpression: " + e); RESULT = e; :} |
		InclusiveOrExpression OR ExclusiveOrExpression
		;
		
ConditionalAndExpression
	::= InclusiveOrExpression:i 
		{: Logger.print("ConditionalAndExpression InclusiveOrExpression: " + i); RESULT = i; :} |
		
		ConditionalAndExpression ANDAND InclusiveOrExpression
		;
		
ConditionalOrExpression
	::= ConditionalAndExpression:c 
		{: Logger.print("ConditionalOrExpression ConditionalAndExpression: " + c); RESULT = c; :} |
		ConditionalOrExpression OROR ConditionalAndExpression
		;
		
ConditionalExpression
	::= ConditionalOrExpression:c 
		{: Logger.print("ConditionalExpression ConditionalOrExpression: " + c); RESULT = c; :} |
		
		ConditionalOrExpression QUESTION Expression COLON Expression
		;
		
Assignment
	::= UnaryExpression AssignmentOperator Expression
		;
		
AssignmentOperator
	::= EQ | PLUSEQ | MINUSEQ | MULTEQ | DIVEQ | MODEQ | ANDEQ | OREQ | XOREQ | LSHIFTEQ | RSHIFTEQ
		;
		
Expression
	::= ConditionalExpression:c
		{: Logger.print("Expression ConditionalExpression: " + c);
		   RESULT = c; :} |
		Assignment
		;
		
ConstantExpression
	::= Expression
		;

/* -------------------------------------------------- *
 *                     Statements                     *
 * -------------------------------------------------- */

statement
	::= LabeledStatement |
		DeclarationStatement:d
		{: Logger.print("statement DeclarationStatement: " + d); RESULT = d; :} |
		
		EmbeddedStatement:e
		{: Logger.print("statement EmbeddedStatement: " + e); RESULT = e; :}
		;
		
EmbeddedStatement
	::= EmbeddedStatement_Possibilities:e
		{: Logger.print("EmbeddedStatement EmbeddedStatement_Possibilities: " + e);
		   RESULT = e; :}
		;
		
Block
	::= LBRACE StatementList:s RBRACE 
		{: Logger.print("Block StatementList: " + s);
		   RESULT = s; :} |
		LBRACE RBRACE
		;
		
StatementList
	::= statement:s
		{: Logger.print("StatementList statement: " + s);
		   MethodItems methodItems = new MethodItems();
		   methodItems.addItem(s);
		   RESULT = methodItems; :} |
	
		StatementList:sl statement:s
		{: Logger.print("StatementList StatementList: " + sl + " statement: " + s); 
		   ((MethodItems) sl).addItem(s);
		   RESULT = sl; :}
		;
		
EmptyStatement
	::= SEMICOLON
		;
		
LabeledStatement
	::= IDENTIFIER COLON statement
		;
		
DeclarationStatement
	::= LocalVariableDeclaration:l SEMICOLON 
		{: Logger.print("DeclarationStatement LocalVariableDeclaration: " + l); RESULT = l; :} |
		LocalConstantDeclaration SEMICOLON
		;
		
LocalVariableDeclaration
	::= type:t LocalVariableDeclarators:vars
		{: Expression e = (Expression) t;
		   Logger.print("LocalVariableDeclaration type: " + e.type + " Declaration: " + vars);
		   List<IdentifierValueType> idsValues = (ArrayList<IdentifierValueType>) vars;
		   for (IdentifierValueType var : idsValues) {
		       if (var.valueType != null && (!((Type) var.valueType).equals(e.type))) {
		           throw new SemanticException("Incompatible Types on Field " + var.identifier + " Initializer");
		       } else {
		           Variable v;
		           if (var.valueType != null) {
		               v = new Variable(e.type, var.identifier, var.value);
		           } else {
		               v = new Variable(e.type, var.identifier);
		           }
		           RESULT = v;
		       }
		   }
		:}
		;
		
LocalVariableDeclarators
	::= LocalVariableDeclarator:l 
		{: Logger.print("LocalVariableDeclarators: " + l);
		   List<IdentifierValueType> vars = new ArrayList<IdentifierValueType>(); 
		   vars.add((IdentifierValueType) l); 
		   RESULT = vars; :} |
	
		LocalVariableDeclarators:vars COMMA LocalVariableDeclarator:l
		{: Logger.print("LocalVariableDeclarators COMMA LocalVariableDeclarator: " + vars); 
		   ((ArrayList<IdentifierValueType>) vars).add((IdentifierValueType) l); 
		   RESULT = vars; :}
		;
		
LocalVariableDeclarator
	::= IDENTIFIER:i
		{: Logger.print("LocalVariableDeclarator IDENTIFIER: " + i);
		   RESULT = new IdentifierValueType(i.toString()); :} |
		   
		IDENTIFIER:i EQ LocalVariableInitializer:l
		{: Expression e = (Expression) l;
		   Logger.print("LocalVariableDeclarator IDENTIFIER: " + i + " LocalVariableInitializer: " + e);
		   RESULT = new IdentifierValueType(i.toString(), e.type, e.value); :}
		;
		
LocalVariableInitializer
	::= Expression:e 
		{: Logger.print("LocalVariableInitializer Expression"); RESULT = e; :}|
		ArrayInitializer
		;
		
LocalConstantDeclaration
	::= CONST type ConstantDeclarators
		;

ExpressionStatement
	::= StatementExpression SEMICOLON
		;
		
StatementExpression
	::= StatementExpression_Possibilities
		;
		
SelectionStatement
	::= IfStatement:i
		{: Logger.print("SelectionStatement: " + i); RESULT = i; :} |
		
		SwitchStatement
		;
		
IfStatement
	::= IF LPAREN BooleanExpression:b RPAREN EmbeddedStatement:e 
		{: Logger.print("IfStatement no ELSE BooleanExpression: " + b + " EmbeddedStatement: " + e );
		   IfStatement stm = new IfStatement((Expression) b);
		   if (e != null) stm.ifItems.add((MethodItems) e);
		   RESULT = stm; :} |
		
		IF LPAREN BooleanExpression:b RPAREN EmbeddedStatement:e ELSE EmbeddedStatement:e1
		{: Logger.print("IfStatement BooleanExpression: " + b + " EmbeddedStatement: " + e + " ELSE EmbeddedStatement: " + e1); 
		   IfStatement stm = new IfStatement((Expression) b);
		   if (e != null) stm.ifItems.add((MethodItems) e);
		   if (e1 != null) stm.elseItems.add((MethodItems) e1);
		   RESULT = stm; :} 
		;
		
BooleanExpression
	::= Expression:e
		{: Logger.print("BooleanExpression: " + e);
		   if (!((Expression) e).type.toString().equals("bool")) throw new SemanticException("IF Condition is not Boolean");
		   RESULT = e; :}
		;
		
SwitchStatement
	::= SWITCH LPAREN Expression RPAREN SwitchBlock
		;
		
SwitchBlock
	::= LBRACE SwitchSections_Opt RBRACE
		;
		
SwitchSections
	::= SwitchSection |
		SwitchSections SwitchSection
		;

SwitchSection
	::= SwitchLabels StatementList
		;
		
SwitchLabels
	::= SwitchLabel |
		SwitchLabels SwitchLabel
		;
		
SwitchLabel
	::= CASE ConstantExpression COLON |
		DEFAULT COLON
		;
		
IterationStatement
	::= WhileStatement |
		DoStatement |
		ForStatement |
		ForeachStatement
		;
		
WhileStatement
	::= WHILE LPAREN Expression RPAREN EmbeddedStatement
		;
		
DoStatement
	::= DO EmbeddedStatement WHILE LPAREN BooleanExpression RPAREN SEMICOLON
		;
		
ForStatement
	::= FOR LPAREN ForInitializer_Opt SEMICOLON ForCondition_Opt SEMICOLON ForIterator_Opt RPAREN EmbeddedStatement
		;
		
ForInitializer
	::= LocalVariableDeclaration |
		StatementExpressionList
		;

ForCondition
	::= BooleanExpression
		;
		
ForIterator
	::= StatementExpressionList
		;

StatementExpressionList
	::= StatementExpression |
		StatementExpressionList COMMA StatementExpression
		;
		
ForeachStatement
	::= FOREACH LPAREN type IDENTIFIER IN Expression RPAREN EmbeddedStatement
		;
		
JumpStatement
	::= BreakStatement |
		ContinueStatement |
		GotoStatement |
		ReturnStatement:r 
		{: Logger.print("JumpStatement ReturnStatement: " + r); 
		   RESULT = r; :} |
		ThrowStatement
		;
		
BreakStatement
	::= BREAK SEMICOLON
		;
		
ContinueStatement
	::= CONTINUE SEMICOLON
		;
		
GotoStatement
	::= GOTO IDENTIFIER |
		GOTO CASE ConstantExpression SEMICOLON |
		GOTO DEFAULT SEMICOLON
		;
		
ReturnStatement
	::= RETURN Expression:e SEMICOLON 
		{: Logger.print("ReturnStatement Expression: " + e);
		   Expression temp = (Expression) e;
		   RESULT = new ReturnStatement(temp); :} |
		   
		RETURN SEMICOLON
		{: Logger.print("ReturnStatement Expression: null");
		   RESULT = new Expression("return", null); :}
		;
		
ThrowStatement
	::= THROW Expression_Opt SEMICOLON
		;
	
TryStatement
	::= TRY Block CatchClauses |
		TRY Block FinallyClause |
		TRY Block CatchClauses FinallyClause
		;
		
CatchClauses
	::= SpecificCatchClauses GeneralCatchClause_Opt |
		SpecificCatchClauses_Opt GeneralCatchClause
		;
		
SpecificCatchClauses
	::= SpecificCatchClause |
		SpecificCatchClauses SpecificCatchClause
		;
		
SpecificCatchClause
	::= CATCH LPAREN type Identifier_Opt RPAREN Block
		;
		
GeneralCatchClause
	::= CATCH Block
		;
		
FinallyClause
	::= FINALLY Block
		;
		
CheckedStatement
	::= CHECKED Block
		;
		
UncheckedStatement
	::= UNCHECKED Block
		;
		
LockStatement
	::= LOCK LPAREN Expression RPAREN EmbeddedStatement
		;
		
UsingStatement
	::= USING LPAREN ResourceAcquisition RPAREN EmbeddedStatement
		;
		
ResourceAcquisition
	::= LocalVariableDeclaration |
		Expression
		;

/* -------------------------------------------------- *
 *                     Namespaces                     *
 * -------------------------------------------------- */

compilation_unit
	::= UsingDirectives_Opt GlobalAttributes_Opt NamespaceMemberDeclarations_Opt
		{: SemanticAnalysis.getInstance().toAssembly(); :}
		;


NamespaceDeclaration
	::= NAMESPACE QualifiedIdentifier NamespaceBody Semicolon_Opt
		;
		
QualifiedIdentifier
	::= IDENTIFIER |
		QualifiedIdentifier DOT IDENTIFIER
		;
		
NamespaceBody
	::= LBRACE UsingDirectives_Opt NamespaceMemberDeclarations_Opt RBRACE
		;
	
UsingDirectives
	::= UsingDirective |
		UsingDirectives UsingDirective
		;
		
UsingDirective
	::= UsingAliasDirective |
		UsingNamespaceDirective
		;
	
UsingAliasDirective
	::= USING IDENTIFIER EQ namespace_or_type_name SEMICOLON
		;
		
UsingNamespaceDirective
	::= USING namespace_or_type_name SEMICOLON
		;

NamespaceMemberDeclarations
	::= NamespaceMemberDeclaration |
		NamespaceMemberDeclarations NamespaceMemberDeclaration
		;

NamespaceMemberDeclaration
	::= NamespaceDeclaration |
		TypeDeclaration
		;
		
TypeDeclaration
	::= class_declaration |
		struct_declaration |
		interface_declaration |
		enum_declaration |
		delegate_declaration
		;
		
/* -------------------------------------------------- *
 *                      Classes                       *
 * -------------------------------------------------- */

class_declaration
	::= Attributes_Opt Modifiers_Opt CLASS IDENTIFIER:i ClassBase_Opt ClassBody Semicolon_Opt
		;
		
ClassBase
	::= COLON type |
		COLON InterfaceTypeList |
		COLON type COMMA InterfaceTypeList
		;
		
InterfaceTypeList
	::= namespace_or_type_name |
		InterfaceTypeList COMMA namespace_or_type_name
		;
		
ClassBody
	::= LBRACE ClassMemberDeclarations_Opt RBRACE
		;
		
ClassMemberDeclarations
	::= ClassMemberDeclaration |
		ClassMemberDeclarations ClassMemberDeclaration
		;
		
ClassMemberDeclaration
	::= ClassMemberDeclaration_Possibilities
		;

ConstantDeclaration
	::= Attributes_Opt Modifiers_Opt CONST type ConstantDeclarators SEMICOLON
		;
		
ConstantDeclarators
	::= ConstantDeclarator |
		ConstantDeclarators COMMA ConstantDeclarator
		;
		
ConstantDeclarator
	::= IDENTIFIER EQ ConstantExpression
		;
		
FieldDeclaration
	::= Attributes_Opt Modifiers type:t VariableDeclarators:vars SEMICOLON
		{: Expression e = (Expression) t;
		   Logger.print("FieldDeclaration type: " + e.type + " Declaration: " + vars);
		   List<IdentifierValueType> idsValues = (ArrayList<IdentifierValueType>) vars;
		   for (IdentifierValueType var : idsValues) {
		       if (var.valueType != null && (!((Type) var.valueType).equals(e.type))) {
		           throw new SemanticException("Incompatible Types on Field " + var.identifier + " Initializer");
		       } else {
		           if (var.valueType != null) {
		               SemanticAnalysis.getInstance().addVariable(new Variable(e.type, var.identifier, var.value));
		           } else {
		               SemanticAnalysis.getInstance().addVariable(new Variable(e.type, var.identifier));
		           }
		       }
		   } :}
		;
		
VariableDeclarators
	::= VariableDeclarator:v 
		{: Logger.print("VariableDeclarators: " + v);
		   List<IdentifierValueType> vars = new ArrayList<IdentifierValueType>(); 
		   vars.add((IdentifierValueType) v); 
		   RESULT = vars; :}|
	
		VariableDeclarators:vars COMMA VariableDeclarator:v
		{: Logger.print("VariableDeclarators COMMA VariableDeclarator: " + vars); 
		   ((ArrayList<IdentifierValueType>) vars).add((IdentifierValueType) v); 
		   RESULT = vars; :}
		;
		
VariableDeclarator
	::= IDENTIFIER:i
		{: Logger.print("VariableDeclarator IDENTIFIER: " + i);
		   RESULT = new IdentifierValueType(i.toString()); :} |
	
		IDENTIFIER:i EQ VariableInitializer:v
		{: Logger.print("VariableDeclarator IDENTIFIER: " + i + " VariableInitializer: " + v);
		   RESULT = new IdentifierValueType(i.toString(), ((Expression) v).type, ((Expression) v).value); :}
		;
		
VariableInitializer
	::= Expression:e 
		{: Logger.print("VariableInitializer Expression: " + e);
		   RESULT = e; :} |
		ArrayInitializer
		;
		
MethodDeclaration
	::= Attributes_Opt Modifiers type:t namespace_or_type_name:n LPAREN RPAREN Block:b
		{: Expression e = (Expression) t;
		   Logger.print("Method name: " + n + " type: " + e.type);
		   Method m = new Method(e.type, n.toString());
		   if (!e.type.toString().equals("void")) {
		       if (b != null) {
		           for (Statement stm : ((MethodItems) b).statements) {
		                if ((stm instanceof ReturnStatement)) {
		                	if (((ReturnStatement) stm).value.type.equals(e.type)) {
		                		((MethodItems) b).setMethod(m);
			                    break;
		                	} else {
		                		throw new SemanticException("Method: " + m + " should return " + e.type);
		                	}
		                }
		           }
		       } else {
		           throw new SemanticException("Method: " + m + " should return " + e.type);
		       }		       
		   } else {
		       if (b != null) {
		           ((MethodItems) b).setMethod(m);
		       }
		   }
		   SemanticAnalysis.getInstance().addMethod(m); :} |
		
		Attributes_Opt Modifiers type:t namespace_or_type_name:n LPAREN FormalParameterList:f RPAREN Block:b
		{: List<Parameter> params = ((ArrayList<Parameter>) f);
		   Expression e = (Expression) t;
		   Logger.print("Method name: " + n + " type: " + e.type + " params: " + params.toString());
		   Method m = new Method(e.type, n.toString(), params);
		   if (!e.type.toString().equals("void")) {
		       if (b != null) {
		           for (Statement stm : ((MethodItems) b).statements) {
		                if ((stm instanceof ReturnStatement)) {
		                	if (((ReturnStatement) stm).value.type.equals(e.type)) {
		                		((MethodItems) b).setMethod(m);
			                    break;
		                	} else {
		                		throw new SemanticException("Method: " + m + " should return " + e.type);
		                	}
		                }
		           }
		       } else {
		           throw new SemanticException("Method: " + m + " should return " + e.type);
		       }		       
		   } else {
		       if (b != null) {
		           ((MethodItems) b).setMethod(m);
		       }
		   }
		   SemanticAnalysis.getInstance().addMethod(m); :} |
		
		Attributes_Opt Modifiers type:t namespace_or_type_name:n LPAREN RPAREN SEMICOLON 
		{: Expression e = (Expression) t;
		   Logger.print("Method name: " + n + " type: " + e.type);  
		   SemanticAnalysis.getInstance().addMethod(new Method(e.type, n.toString())); :} |
		
		Attributes_Opt Modifiers type:t namespace_or_type_name:n LPAREN FormalParameterList:f RPAREN SEMICOLON
		{: List<Parameter> params = ((ArrayList<Parameter>) f);
		   Expression e = (Expression) t; 
		   Logger.print("Method name: " + n + " type: " + e.type + " params: " + params.toString()); 
		   SemanticAnalysis.getInstance().addMethod(new Method(e.type, n.toString(), params)); :}
		;
				
FormalParameterList
	::= FixedParameters:f
		{: Logger.print("FormalParameterList: " + f); RESULT = f; :} |
		
		FixedParameters COMMA ParameterArray |
		
		ParameterArray
		;
		
FixedParameters
	::= FixedParameter:f
		{: Logger.print("FixedParameters: " + f); List<Parameter> params = new ArrayList<Parameter>(); params.add((Parameter) f); RESULT = params; :} |
		
		FixedParameters:params COMMA FixedParameter:f
		{: Logger.print("FixedParameters COMMA FixedParameter"); ((ArrayList<Parameter>) params).add((Parameter) f); RESULT = params; :}
		;
		
FixedParameter
	::= Attributes_Opt Modifier_Opt type:t IDENTIFIER:i
		{: Expression e = (Expression) t;
		   Logger.print("FixedParamenter name: " + i + " type: " + e.type);
		   RESULT = new Parameter(e.type, i.toString()); :}
		;
		
ParameterArray
	::= Attributes_Opt PARAMS array_type IDENTIFIER
		;
		
PropertyDeclaration
	::= Attributes_Opt Modifiers type namespace_or_type_name LBRACE AcessorDeclarations RBRACE
		;

AcessorDeclarations
	::= GetAcessorDeclaration SetAcessorDeclaration_Opt |
		SetAcessorDeclaration GetAcessorDeclaration_Opt
		;
		
GetAcessorDeclaration
	::= Attributes_Opt GET AcessorBody
		;
		
SetAcessorDeclaration
	::= Attributes_Opt SET AcessorBody
		;
		
AcessorBody
	::= Block |
		SEMICOLON
		;
		
EventDeclaration
	::= Attributes_Opt Modifiers_Opt EVENT type VariableDeclarators SEMICOLON |
		Attributes_Opt Modifiers_Opt EVENT type namespace_or_type_name LBRACE EventAcessorDeclarations RBRACE
		;
		
EventAcessorDeclarations
	::= AddAcessorDeclaration RemoveAcessorDeclaration |
		RemoveAcessorDeclaration AddAcessorDeclaration
		;
		
AddAcessorDeclaration
	::= Attributes_Opt ADD Block
		;
		
RemoveAcessorDeclaration
	::= Attributes_Opt REMOVE Block
		;
		
IndexerDeclaration
	::= Attributes_Opt Modifiers IndexerDeclarator LBRACE AcessorDeclarations RBRACE
		;
		
IndexerDeclarator
	::= type THIS LBRACK FormalParameterList RBRACK |
		type namespace_or_type_name DOT THIS LBRACK FormalParameterList RBRACK
		;
		
OperatorDeclaration
	::= Attributes_Opt Modifiers OperatorDeclarator OperatorBody
		;
		
OperatorDeclarator
	::= UnaryOperatorDeclarator |
		BinaryOperatorDeclarator |
		ConversionOperatorDeclarator
		;
		
UnaryOperatorDeclarator
	::= type OPERATOR Operator LPAREN type IDENTIFIER RPAREN
		;
		
BinaryOperatorDeclarator
	::= type OPERATOR Operator LPAREN type IDENTIFIER COMMA type IDENTIFIER RPAREN
		;
		
ConversionOperatorDeclarator
	::= IMPLICIT OPERATOR type LPAREN type IDENTIFIER RPAREN |
		EXPLICIT OPERATOR type LPAREN type IDENTIFIER RPAREN
		;
		
OperatorBody
	::= Block |
		SEMICOLON
		;

ConstructorDeclaration
	::= Attributes_Opt Modifiers IDENTIFIER LPAREN FormalParameterList_Opt RPAREN ConstructorInitializer_Opt ConstructorBody
		;
		
ConstructorInitializer
	::= COLON BASE LPAREN ArgumentList_Opt RPAREN |
		COLON THIS LPAREN ArgumentList_Opt RPAREN
		;
		
ConstructorBody
	::= Block |
		SEMICOLON
		;
		
StaticConstructorDeclaration
	::= Attributes_Opt Modifiers IDENTIFIER LPAREN RPAREN StaticConstructorBody
		;

StaticConstructorBody
	::= Block |
		SEMICOLON
		;

DestructorDeclaration
	::= Attributes_Opt EXTERN COMP IDENTIFIER LPAREN RPAREN DestructorBody |
		Attributes_Opt COMP IDENTIFIER LPAREN RPAREN DestructorBody
		;
		
DestructorBody
	::= Block
		;
		
/* -------------------------------------------------- *
 *                      Structs                       *
 * -------------------------------------------------- */
 
struct_declaration
	::= Attributes_Opt Modifiers_Opt STRUCT IDENTIFIER StructInterfaces_Opt LBRACE StructMemberDeclarations_Opt RBRACE Semicolon_Opt
		;
 
StructInterfaces
	::= COLON InterfaceTypeList
		;
		
StructMemberDeclarations
	::= StructMemberDeclaration |
		StructMemberDeclarations StructMemberDeclaration
		;
		
StructMemberDeclaration
	::= StructMemberDeclaration_Possibilities
		;
		
/* -------------------------------------------------- *
 *                       Arrays                       *
 * -------------------------------------------------- */
 
array_type
	::= type:t RankSpecifiers {: RESULT = t + "[]"; :}
		;
	
RankSpecifiers
	::= RankSpecifier |
		RankSpecifiers RankSpecifier
		;

RankSpecifier
	::= LBRACK DimSeparators_Opt RBRACK
		;
		
DimSeparators
	::= COMMA |
		DimSeparators COMMA
		;
		
ArrayInitializer
	::= LBRACE VariableInitializerList_Opt RBRACE |
		LBRACE VariableInitializerList COMMA RBRACE
		;
		
VariableInitializerList
	::= VariableInitializer |
		VariableInitializerList COMMA VariableInitializer
		;
		
/* -------------------------------------------------- *
 *                     Interfaces                     *
 * -------------------------------------------------- */
 
interface_declaration
	::= Attributes_Opt Modifiers_Opt INTERFACE IDENTIFIER InterfaceBase_Opt LBRACE InterfaceMemberDeclarations_Opt RBRACE Semicolon_Opt
		;
		
InterfaceBase
	::= COLON InterfaceTypeList
		;
		
InterfaceMemberDeclarations
	::= InterfaceMemberDeclaration |
		InterfaceMemberDeclarations InterfaceMemberDeclaration
		;
		
InterfaceMemberDeclaration
	::= InterfaceMethodDeclaration |
		InterfacePropertyDeclaration |
		InterfaceEventDeclaration |
		InterfaceIndexerDeclaration
		;

InterfaceMethodDeclaration
	::= Attributes_Opt NEW type IDENTIFIER LPAREN FormalParameterList_Opt RPAREN SEMICOLON
		;
		
InterfacePropertyDeclaration
	::= Attributes_Opt NEW type IDENTIFIER LBRACE InterfaceAcessors RBRACE
		;
		
InterfaceAcessors
	::= AttributesOpt_Get_Semicolon |
		AttributesOpt_Set_Semicolon |
		AttributesOpt_Get_Semicolon AttributesOpt_Set_Semicolon |
		AttributesOpt_Set_Semicolon AttributesOpt_Get_Semicolon
		;
		
InterfaceEventDeclaration
	::= Attributes_Opt NEW EVENT type IDENTIFIER SEMICOLON
		;
		
InterfaceIndexerDeclaration
	::= Attributes_Opt NEW type THIS LBRACK FormalParameterList RBRACK LBRACE InterfaceAcessors RBRACE
		;
		
/* -------------------------------------------------- *
 *                        Enum                        *
 * -------------------------------------------------- */
 
enum_declaration
	::= Attributes_Opt Modifiers_Opt ENUM IDENTIFIER EnumBase_Opt LBRACE RBRACE Semicolon_Opt |
		Attributes_Opt Modifiers_Opt ENUM IDENTIFIER EnumBase_Opt LBRACE EnumMemberDeclarations COMMA RBRACE Semicolon_Opt
		;
		
EnumBase
	::= COLON IntegralType_Possibilities
		;
				
EnumMemberDeclarations
	::= EnumMemberDeclaration |
		EnumMemberDeclarations COMMA EnumMemberDeclaration
		;
		
EnumMemberDeclaration
	::= AttibutesOpt_Identifier |
		AttibutesOpt_Identifier EQ ConstantExpression
		;
		
/* -------------------------------------------------- *
 *                     Delegates                      *
 * -------------------------------------------------- */
 
delegate_declaration
	::= Attributes_Opt Modifiers_Opt DELEGATE type IDENTIFIER LPAREN FormalParameterList_Opt RPAREN SEMICOLON
		;
		
/* -------------------------------------------------- *
 *                     Attributes                     *
 * -------------------------------------------------- */
 
global_attributes
	::= GlobalAttributeSections
		;
		
GlobalAttributeSections
	::= GlobalAttributeSection |
		GlobalAttributeSections GlobalAttributeSection
		;
		

GlobalAttributeSection
	::= LBRACK ASSEMBLY COLON AttributeList Comma_Opt RBRACK |
		LBRACK MODULE COLON AttributeList Comma_Opt RBRACK
		;
		
Attributes
	::= AttributeSections
		;
		
AttributeSections
	::= AttributeSection |
		AttributeSections AttributeSection
		;

AttributeSection
	::= LBRACK AttributeTargetSpecifier_Opt AttributeList Comma_Opt RBRACK
		;
		
AttributeTargetSpecifier
	::= AttributeTarget COLON
		;
		
AttributeTarget
	::= FIELD | EVENT | METHOD | PARAM | PROPERTY | RETURN | TYPE
		;
		
AttributeList
	::= Attribute |
		AttributeList COMMA Attribute
		;
		
Attribute
	::= namespace_or_type_name AttributeArguments_Opt
		;
		
AttributeName
	::= namespace_or_type_name
		;
		
AttributeArguments
	::= LPAREN PositionalArgumentList_Opt RPAREN |
		LPAREN PositionalArgumentList COMMA NamedArgumentList RPAREN |
		LPAREN NamedArgumentList RPAREN
		;
		
PositionalArgumentList
	::= PositionalArgument |
		PositionalArgumentList COMMA PositionalArgument
		;

PositionalArgument
	::= AttributeArgumentExpression
		;
		
NamedArgumentList
	::= NamedArgument |
		NamedArgumentList COMMA NamedArgument
		;
		
NamedArgument
	::= IDENTIFIER EQ AttributeArgumentExpression
		;
		
AttributeArgumentExpression
	::= Expression
		;
				
/* -------------------------------------------------- *
 *                   Possibilities                    *
 * -------------------------------------------------- */
 
Modifier
	::= NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | ABSTRACT | SEALED |
		STATIC | READONLY | VOLATILE | VIRTUAL | OVERRIDE | EXTERN | REF | OUT
		;
		
Modifier_Opt
	::= | Modifier
		;
		
Modifiers
	::= Modifier |
		Modifiers Modifier
		;
		
Modifiers_Opt
	::= | Modifiers
		;
		
Operator
	::= PLUS | MINUS | MULT | DIV | MOD | AND | OR | XOR | LSHIFT | RSHIFT | NOTEQ | GT | LT | GTEQ | LTEQ |
		COMP | PLUSPLUS | MINUSMINUS | TRUE | FALSE
		;
		
IntegralType_Possibilities
	::= SBYTE:s {: Logger.print("Integral Possibilities: sbyte"); RESULT = new Expression((String) s, new Type("sbyte")); :} | 
		BYTE:b {: Logger.print("Integral Possibilities: byte"); RESULT = new Expression((String) b, new Type("byte")); :} | 
		SHORT:s  {: Logger.print("Integral Possibilities: short"); RESULT = new Expression((String) s, new Type("short")); :} |
		USHORT:u  {: Logger.print("Integral Possibilities: ushort"); RESULT = new Expression((String) u, new Type("ushort")); :} |
		INT:i  {: Logger.print("Integral Possibilities: int"); RESULT = new Expression((String) i, new Type("int")); :} |
		UINT:u  {: Logger.print("Integral Possibilities: uint"); RESULT = new Expression((String) u, new Type("uint")); :} |
		LONG:l  {: Logger.print("Integral Possibilities: long"); RESULT = new Expression((String) l, new Type("long")); :}  |
		ULONG:u  {: Logger.print("Integral Possibilities: ulong"); RESULT = new Expression((String) u, new Type("ulong")); :}  |
		CHAR:c  {: Logger.print("Integral Possibilities: char"); RESULT = new Expression((String) c, new Type("char")); :} 
		;
		
ClassMemberDeclaration_Possibilities
	::= ConstantDeclaration |
		FieldDeclaration |
		MethodDeclaration |
		PropertyDeclaration |
		EventDeclaration |
		IndexerDeclaration |
		OperatorDeclaration |
		ConstructorDeclaration |
		DestructorDeclaration |
		StaticConstructorDeclaration |
		TypeDeclaration
		;
		
StructMemberDeclaration_Possibilities
	::= ConstantDeclaration |
		FieldDeclaration |
		MethodDeclaration |
		PropertyDeclaration |
		EventDeclaration |
		IndexerDeclaration |
		OperatorDeclaration |
		ConstructorDeclaration |
		StaticConstructorDeclaration |
		TypeDeclaration
		;
		
EmbeddedStatement_Possibilities
	::= Block:b
		{: Logger.print("EmbeddedStatement_Possibilities Block");
		   RESULT = b; :} |
		
		EmptyStatement |
		ExpressionStatement |
		
		SelectionStatement:s 
		{: Logger.print("EmbeddedStatement_Possibilities SelectionStatement: " + s); 
		   RESULT = s; :} |
		
		IterationStatement |
		
		JumpStatement:j
		{: Logger.print("EmbeddedStatement_Possibilities JumpStatement");
		   RESULT = j; :} |
		
		TryStatement |
		CheckedStatement |
		UncheckedStatement |
		LockStatement |
		UsingStatement
		;
		
StatementExpression_Possibilities
	::= InvocationExpression |
		ObjectCreationExpression |
		Assignment |
		PostIncrementExpression |
		PostDecrementExpression |
		PreIncrementExpression |
		PreDecrementExpression
		;
		
/* -------------------------------------------------- *
 *                     Repetition                     *
 * -------------------------------------------------- */
 
AttributesOpt_ModifiersOpt_Event_Type
	::= Attributes_Opt Modifiers_Opt EVENT type
		;

Operator_Type_Lparen_Type_Identifier_Rparen
	::= OPERATOR type LPAREN type IDENTIFIER RPAREN
		;
		
AttributesOpt_Get_Semicolon
	::= Attributes_Opt GET SEMICOLON
		;
		
AttributesOpt_Set_Semicolon
	::= Attributes_Opt SET SEMICOLON
		;
		
AttibutesOpt_Identifier
	::= Attributes_Opt IDENTIFIER
		;
 
/* -------------------------------------------------- *
 *                      Optional                      *
 * -------------------------------------------------- */
		
UsingDirectives_Opt
	::= | UsingDirectives
		;
		
GlobalAttributes_Opt
	::= | global_attributes
		;
		
NamespaceMemberDeclarations_Opt
	::= | NamespaceMemberDeclarations
		;
		
Semicolon_Opt
	::= | SEMICOLON
		;
		
Attributes_Opt
	::= | Attributes
		;
		
ClassBase_Opt
	::= | ClassBase
		;
		
ClassMemberDeclarations_Opt
	::= | ClassMemberDeclarations
		;
		
FormalParameterList_Opt
	::= | FormalParameterList
		;
		
SetAcessorDeclaration_Opt
	::= | SetAcessorDeclaration
		;
		
GetAcessorDeclaration_Opt
	::= | GetAcessorDeclaration
		;
		
ConstructorInitializer_Opt
	::= | ConstructorInitializer
		;
		
StructMemberDeclarations_Opt
	::= | StructMemberDeclarations
		;
		
StructInterfaces_Opt
	::= | StructInterfaces
		;
		
ArgumentList_Opt
	::= | argument_list
		;

DimSeparators_Opt
	::= | DimSeparators
		;
		
VariableInitializerList_Opt
	::= | VariableInitializerList
		;
		
InterfaceBase_Opt
	::= | InterfaceBase
		;
		
InterfaceMemberDeclarations_Opt
	::= | InterfaceMemberDeclarations
		;
		
EnumBase_Opt
	::= | EnumBase
		;
		
EnumMemberDeclarations_Opt
	::= | EnumMemberDeclarations
		;
		
AttributeTargetSpecifier_Opt
	::= | AttributeTargetSpecifier
		;
		
AttributeArguments_Opt
	::= | AttributeArguments
		;
		
PositionalArgumentList_Opt
	::= | PositionalArgumentList
		;
		
Comma_Opt
	::= | COMMA
		;
		
StatementList_Opt
	::= | StatementList
		;
		
SwitchSections_Opt
	::= | SwitchSections
		;
		
ForInitializer_Opt
	::= | ForInitializer
		;
		
ForCondition_Opt
	::= | ForCondition
		;
		
ForIterator_Opt
	::= | ForIterator
		;
		
Expression_Opt
	::= | Expression
		;
		
GeneralCatchClause_Opt
	::= | GeneralCatchClause
		;
		
SpecificCatchClauses_Opt
	::= | SpecificCatchClauses
		;
		
Identifier_Opt
	::= | IDENTIFIER
		;
		
RankSpecifiers_Opt
	::= | RankSpecifiers
		;
		
ArrayInitializer_Opt
	::= | ArrayInitializer
		;